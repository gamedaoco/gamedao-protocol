// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.20;

/**
 * @title GameId
 * @dev Utility library for generating hierarchical IDs according to GIP-006
 * @author GameDAO AG
 */
library GameId {
    /**
     * @dev Generate a base 8-character alphanumeric ID
     * @param context Context string for ID generation
     * @param nonce Unique nonce for collision resistance
     * @return Generated bytes8 ID
     */
    function generateId(string memory context, uint256 nonce) internal view returns (bytes8) {
        return bytes8(keccak256(abi.encodePacked(context, nonce, block.timestamp, block.prevrandao)));
    }

    /**
     * @dev Generate hierarchical proposal ID: orgId-P-proposalId
     * @param orgId Organization ID (bytes8)
     * @param proposalNonce Proposal counter for uniqueness
     * @return Generated hierarchical proposal ID string
     */
    function generateProposalId(bytes8 orgId, uint256 proposalNonce) internal view returns (string memory) {
        bytes8 proposalId = generateId("proposal", proposalNonce);
        return string(abi.encodePacked(
            orgId,
            "-P-",
            proposalId
        ));
    }

    /**
     * @dev Generate hierarchical campaign ID: orgId-C-campaignId
     * @param orgId Organization ID (bytes8)
     * @param campaignNonce Campaign counter for uniqueness
     * @return Generated hierarchical campaign ID string
     */
    function generateCampaignId(bytes8 orgId, uint256 campaignNonce) internal view returns (string memory) {
        bytes8 campaignId = generateId("campaign", campaignNonce);
        return string(abi.encodePacked(
            orgId,
            "-C-",
            campaignId
        ));
    }

    /**
     * @dev Extract organization ID from hierarchical proposal ID
     * @param hierarchicalId Full hierarchical ID (e.g., "ABCD1234-P-EFGH5678")
     * @return Organization ID (bytes8)
     */
    function extractOrgId(string memory hierarchicalId) internal pure returns (bytes8) {
        bytes memory idBytes = bytes(hierarchicalId);
        require(idBytes.length >= 8, "Invalid hierarchical ID");

        bytes8 orgId;
        assembly {
            orgId := mload(add(idBytes, 32))
        }
        return orgId;
    }

    /**
     * @dev Extract entity ID from hierarchical ID
     * @param hierarchicalId Full hierarchical ID (e.g., "ABCD1234-P-EFGH5678")
     * @return Entity ID (bytes8)
     */
    function extractEntityId(string memory hierarchicalId) internal pure returns (bytes8) {
        bytes memory idBytes = bytes(hierarchicalId);
        require(idBytes.length >= 19, "Invalid hierarchical ID"); // 8 + 3 + 8 = 19 minimum

        bytes8 entityId;
        assembly {
            entityId := mload(add(idBytes, 43)) // 32 + 8 + 3 = 43
        }
        return entityId;
    }

    /**
     * @dev Validate hierarchical ID format
     * @param hierarchicalId ID to validate
     * @param expectedType Expected type ("P" for proposal, "C" for campaign)
     * @return True if valid format
     */
    function validateHierarchicalId(string memory hierarchicalId, string memory expectedType) internal pure returns (bool) {
        bytes memory idBytes = bytes(hierarchicalId);
        bytes memory typeBytes = bytes(expectedType);

        if (idBytes.length != 19) return false; // 8 + 1 + 1 + 1 + 8 = 19
        if (idBytes[8] != bytes1("-")) return false;
        if (idBytes[9] != typeBytes[0]) return false;
        if (idBytes[10] != bytes1("-")) return false;

        return true;
    }

    /**
     * @dev Convert hierarchical ID to bytes32 for backward compatibility
     * @param hierarchicalId String ID to convert
     * @return bytes32 hash of the ID
     */
    function toBytes32(string memory hierarchicalId) internal pure returns (bytes32) {
        return keccak256(bytes(hierarchicalId));
    }

    /**
     * @dev Convert bytes32 to string for display purposes
     * @param id bytes32 ID to convert
     * @return String representation
     */
    function bytes32ToString(bytes32 id) internal pure returns (string memory) {
        bytes memory alphabet = "0123456789abcdef";
        bytes memory str = new bytes(64);

        for (uint256 i = 0; i < 32; i++) {
            str[i * 2] = alphabet[uint8(id[i] >> 4)];
            str[1 + i * 2] = alphabet[uint8(id[i] & 0x0f)];
        }

        return string(str);
    }
}
